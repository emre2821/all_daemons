import json
import os
import re

# Set the input and output directory paths
INPUT_DIR = r"C:\EdenOS_Origin\all_daemons\_daemon_specialty_folders\split_conversations_txt"  # Briar's output folder
OUTPUT_DIR = r"C:\EdenOS_Origin\all_daemons\_daemon_specialty_folders\janvier_cleaned"  # Where we save the chaos files

def clean_filename(s):
    # Clean up the title for file names to ensure it's safe and readable
    return ''.join(c if c.isalnum() else '_' for c in s)

def _detect_speaker_prefix(message: str):
    """If message starts with "[Name]:" or "Name:", return (name, stripped_message). Otherwise, (None, original)."""
    if not message:
        return None, message
    patterns = [
        r"^\s*\[(?P<name>[^\]\r\n]{1,64})\]\s*[:\-]\s*",
        r"^\s*(?P<name>[A-Za-z0-9 _&\-]{1,64})\s*:\s+",
    ]
    for pat in patterns:
        m = re.match(pat, message)
        if m:
            name = m.group("name").strip()
            stripped = re.sub(pat, "", message, count=1)
            return name, stripped
    return None, message


def parse_txt_file(txt_file_path):
    """
    Parse the .txt file generated by Briar, and return the conversation in a cleaned-up format.
    """
    with open(txt_file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    print(f"[Debug] Reading file: {txt_file_path}")
    print("[Debug] File content:\n", content)  # Print the content of the file for debugging

    # We assume the file has the following structure:
    # --- Conversation: <Title> ---
    # [USER] User message here...
    # [ASSISTANT] Assistant message here...
    
    # Clean and format the content
    lines = content.splitlines()
    title = None
    conversation = []
    for line in lines:
        if line.startswith('--- Conversation:'):
            # Extract the title
            title = line.replace('--- Conversation:', '').strip()
        elif line.startswith('['):
            # Clean up each conversation turn
            role, message = line.split(']', 1)
            role = role.strip('[]')
            message = message.strip()

            # If the message begins with an explicit speaker prefix like "[Alfred]:" or "Alfred:",
            # treat that as the actual role, and strip the prefix from the message text.
            detected_role, stripped = _detect_speaker_prefix(message)
            if detected_role:
                role = detected_role
                message = stripped.strip()

            # Handle missing text
            if not message:
                message = "<Message missing parts>"

            conversation.append({"role": role, "message": message})

    if not title or not conversation:
        print(f"[Error] No conversation data found in {txt_file_path}. Skipping.")
    return title, conversation

def convert_to_chaos_format(title, conversation):
    """
    Convert the cleaned-up conversation into a CHAOS-formatted structure.
    """
    chaos_data = {
        "title": title,
        "mapping": {},
        "current_node": 0
    }

    # Build the mapping from the conversation
    current_node = 0
    for idx, turn in enumerate(conversation):
        node_id = str(idx)
        chaos_data["mapping"][node_id] = {
            "message": {
                "author": {"role": turn["role"]},
                "content": {"parts": [turn["message"]]}
            },
            "children": [] if idx == len(conversation) - 1 else [str(idx + 1)]  # Link to the next message
        }
    
    # Set the first node as the starting point
    chaos_data["current_node"] = str(current_node)
    return chaos_data

def process_txt_file(txt_file_path, idx):
    """
    Process a single .txt file, clean it up, and convert it into a .chaos file.
    """
    title, conversation = parse_txt_file(txt_file_path)
    if not title or not conversation:
        print(f"[Error] No conversation data found in {txt_file_path}. Skipping.")
        return

    # Convert the cleaned conversation into CHAOS format
    chaos_data = convert_to_chaos_format(title, conversation)

    # Clean up the title for safe file naming
    safe_title = clean_filename(title)[:48]  # Limit length to avoid long filenames
    outpath = os.path.join(OUTPUT_DIR, f"conversation_{idx + 1}_{safe_title}.chaos")

    # Save the converted data to a .chaos file
    with open(outpath, 'w', encoding='utf-8') as f:
        json.dump(chaos_data, f, indent=2)
    
    print(f"[Janvier] Converted and saved: {outpath}")

def main():
    # Automatically get all .txt files in the input directory (where Briar saved them)
    files = [f for f in os.listdir(INPUT_DIR) if f.endswith('.txt')]
    print(f"[Janvier] Processing {len(files)} conversation files...")

    if not files:
        print("[Error] No .txt files found in the input directory.")
        return

    # Process each file
    for idx, file_name in enumerate(files):
        txt_file_path = os.path.join(INPUT_DIR, file_name)

        try:
            # Process each .txt file
            process_txt_file(txt_file_path, idx)
        except Exception as e:
            print(f"[Error] Failed to process {file_name}: {str(e)}")

    print("[Janvier] Done!")

if __name__ == "__main__":
    main()
