import os
import datetime
import platform
import time
import subprocess
import shutil

try:
    import psutil
    _PSUTIL_OK = True
except Exception:
    _PSUTIL_OK = False

try:
    import sys
    sys.path.append(os.path.join(os.environ.get("EDEN_ROOT", os.getcwd()), "shared", "Daemon_tools", "scripts"))
    from eden_paths import daemon_out_dir  # type: ignore
    _OUT_DIR = daemon_out_dir("John")
except Exception:
    work_root = os.environ.get("EDEN_WORK_ROOT", os.environ.get("EDEN_ROOT", os.getcwd()))
    _OUT_DIR = os.path.join(work_root, "daemons", "Rhea", "_outbox", "John")
    os.makedirs(_OUT_DIR, exist_ok=True)

class JohnDaemon:
    def __init__(self):

        self.name = "John"
        self.role = "Device Manager Daemon"
        self.boot_time = datetime.datetime.fromtimestamp(psutil.boot_time())
        self.log_path = _OUT_DIR
        self.dump_path = os.path.join(self.log_path, "crash_dumps")
        os.makedirs(self.log_path, exist_ok=True)
        os.makedirs(self.dump_path, exist_ok=True)
        self.bsod_logged_file = os.path.join(self.log_path, "last_bsod_logged.txt")
        self.watch_log_file = os.path.join(self.log_path, "john_watch.log")

    def check_bsod_event(self):

        current_boot = datetime.datetime.fromtimestamp(psutil.boot_time()) if _PSUTIL_OK else datetime.datetime.now()
        if os.path.exists(self.bsod_logged_file):
            with open(self.bsod_logged_file, 'r') as f:
                last_logged = f.read().strip()
            return last_logged != str(current_boot)
        return True

    def record_bsod_logged(self):

        with open(self.bsod_logged_file, 'w') as f:
            f.write(str(datetime.datetime.fromtimestamp(psutil.boot_time()) if _PSUTIL_OK else datetime.datetime.now()))

    def create_aftermath_log(self):

        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"bsod_aftermath.{timestamp}.chaos"
        filepath = os.path.join(self.log_path, filename)
        with open(filepath, "w") as f:
            f.write("::crash.log::\n")
            f.write(f"- Timestamp: {timestamp}\n")
            f.write(f"- OS: {platform.platform()}\n")
            f.write(f"- Boot Time: {self.boot_time}\n")
            f.write(f"- Current Boot: {datetime.datetime.fromtimestamp(psutil.boot_time()) if _PSUTIL_OK else 'unknown'}\n")
            f.write(f"- Daemon: {self.name}\n")
            f.write(f"- Role: {self.role}\n")
            f.write("- NOTE: This is an autogenerated log post-BSOD for analysis.\n")
        self.export_event_logs(timestamp)
        self.copy_minidumps(timestamp)

    def export_event_logs(self, timestamp):

        try:
            evtx_path = os.path.join(self.dump_path, f"eventlog_{timestamp}.evtx")
            cmd = f'wevtutil epl System "{evtx_path}" /q:"*[System[(EventID=41 or EventID=1001 or Level=1)]]"'
            subprocess.run(cmd, shell=True, check=True)
        except Exception as e:
            with open(self.watch_log_file, "a") as log:
                log.write(f"[Error exporting event logs] {e}\n")

    def copy_minidumps(self, timestamp):

        minidump_dir = os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "Minidump")
        if os.path.exists(minidump_dir):
            for fname in os.listdir(minidump_dir):
                if fname.lower().endswith(".dmp"):
                    src = os.path.join(minidump_dir, fname)
                    dest = os.path.join(self.dump_path, f"{timestamp}_{fname}")
                    try:
                        shutil.copy(src, dest)
                    except Exception as e:
                        with open(self.watch_log_file, "a") as log:
                            log.write(f"[Error copying dump {fname}] {e}\n")

    def watch_devices(self, interval=10):

        previous_devices = set(self.get_connected_devices())
        while True:
            time.sleep(interval)
            current_devices = set(self.get_connected_devices())
            added = current_devices - previous_devices
            removed = previous_devices - current_devices

            with open(self.watch_log_file, "a") as log:
                timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                for device in added:
                    log.write(f"[{timestamp}] Device added: {device}\n")
                for device in removed:
                    log.write(f"[{timestamp}] Device removed: {device}\n")

            previous_devices = current_devices

    def get_connected_devices(self):

        devices = []
        try:
            if platform.system() == "Windows":
                result = subprocess.check_output("wmic logicaldisk get name", shell=True).decode()
                devices = [line.strip() for line in result.splitlines() if line.strip() and "Name" not in line]
            elif platform.system() == "Linux":
                result = os.listdir("/dev")
                devices = [d for d in result if d.startswith("sd")]
        except Exception as e:
            devices.append(f"Error: {str(e)}")
        return devices

    def run(self):

        with open(self.watch_log_file, "a") as log:
            log.write(f"[{datetime.datetime.now()}] John booted and watching...\n")

        if _PSUTIL_OK and self.check_bsod_event():
            print(f"[{self.name}] Detected BSOD reboot. Creating aftermath log...")
            self.create_aftermath_log()
            self.record_bsod_logged()
        print(f"[{self.name}] Entering watcher mode...")
        self.watch_devices()

if __name__ == "__main__":
    daemon = JohnDaemon()
    daemon.run()


def describe() -> dict:

    return {
        "name": "John",
        "role": "Device watcher + BSOD aftermath logger (Windows)",
        "outputs": {"out_dir": _OUT_DIR},
        "flags": [],
        "safety_level": "normal",
    }


def healthcheck() -> dict:

    status = "ok"; notes = []
    if platform.system() != "Windows":
        status = "warn"; notes.append("non-Windows; limited functionality")
    if not _PSUTIL_OK:
        status = "warn"; notes.append("psutil missing; BSOD detection limited")
    try:
        os.makedirs(_OUT_DIR, exist_ok=True)
    except Exception as e:
        if status == "ok": status = "warn"
        notes.append(f"outdir warn: {e}")
    return {"status": status, "notes": "; ".join(notes)}
